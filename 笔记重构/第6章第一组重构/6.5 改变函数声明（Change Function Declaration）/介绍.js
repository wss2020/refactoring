/*
* 别名：函数改名（Rename Function）

  曾用名：函数改名（Rename Method）

  曾用名：添加参数（Add Parameter）

  曾用名：移除参数（Remove Parameter）

  别名：修改签名（Change Signature）

* */


//修改前
function circum(radius) {}


//修改后
function circumference(radius) {}


/*
动机

   函数是我们将程序拆分成小块的主要方式。函数声明则展现了如何将这些小块组合在一起工作——可以说，它们就是软件系统的关节。和任何构造体一样，系统的好坏很
大程度上取决于关节。好的关节使得给系统添加新部件很容易；而糟糕的关节则不断招致麻烦，让我们难以看清软件的行为，当需求变化时难以找到合适的地方进行修改。
还好，软件是软的，我可以改变这些关节，只是要小心修改。

   对于这些关节而言，最重要的元素当属函数的名字。一个好名字能让我一眼看出函数的用途，而不必查看其实现代码。但起一个好名字并不容易，我很少能第一次就把
名字起对。“就算这个名字有点迷惑人，还是放着别管吧——说到底，不过就是一个名字而已。” 邪恶的混乱魔王就是这样引诱我的。为了拯救程序的灵魂，绝不能上了他的'
当。如果我看到一个函数的名字不对，一旦发现了更好的名字，就得尽快给函数改名。这样，下一次再看到这段代码时，我就不用再费力搞懂其中到底在干什么。
( 有一个改进函数名字的好办法：先写一句注释描述这个函数的用途，再把这句注释变成函数的名字。）

    对于函数的参数，道理也是一样。函数的参数列表阐述了函数如何与外部世界共处。函数的参数设置了一个上下文，只有在这个上下文中，我才能使用这个函数。假
如有一个函数的用途是把某人的电话号码转换成特定的格式，并且该函数的参数是一个人（person），那么我就没法用这个函数来处理公司（company）的电话号码。如
果我把函数接受的参数由“人”改成“电话号码”，这段处理电话号码格式的代码就能被更广泛地使用。

   修改参数列表不仅能增加函数的应用范围，还能改变连接一个模块所需的条件，从而去除不必要的耦合。在前面这个例子中，修改参数列表之后，“处理电话号码格式”
的逻辑所在的模块就无须了解“人”这个概念。减少模块彼此之间的信息依赖，当我要做出修改时就能减轻我大脑的负担——毕竟我的脑容量已经不如从前那么大了（跟我脑
袋的大小没关系）。

   如何选择正确的参数，没有简单的规则可循。我可能有一个简单的函数，用于判断支付是否逾期——如果超期30天未付款，那么这笔支付就逾期了。这个函数的参数应该
是“支付”（payment）对象，还是支付的到期日呢？如果使用支付对象，会使这个函数与支付对象的接口耦合，但好处是可以很容易地访问后者的其他属性，当“逾期”的
逻辑发生变化时就不用修改所有调用该函数的代码——换句话说，提高了该函数的封装度。

   对这道难题，唯一正确的答案是“没有正确答案”，而且答案还会随着时间变化。所以我发现掌握改变函数声明重构手法至关重要，这样当我想好代码中应该有哪些关节
时，才能使代码随着我的理解而演进。

    在本书中引用重构手法时，我通常只使用它的主名称。但“改名”（rename）是改变函数声明的重要应用场景，所以，如果只是用于改名，我会将这个重构称作函数
改名（Rename Function），这样能更清晰地表达我的用意。从做法的角度，不管是给函数改名还是修改参数列表，做法都是一样的。

 */





/*
做法

   对于本书中的大部分重构，我只展示了一套做法。这并非因为只有这一套做法，而是因为大部分情况下，一套标准的做法都管用。不过，改变函数声明是一个例外。它
有一套简单的做法，这套做法常常够用；但在很多时候，有必要以更渐进的方式逐步迁移到达最终结果。所以，在进行此重构时，我会查看变更的范围，自问是否能一步到
位地修改函数声明及其所有调用者。如果可以，我就采用简单的做法。迁移式的做法让我可以逐步修改调用方代码，如果函数被很多地方调用，或者修改不容易，或者要修
改的是一个多态函数，或者对函数声明的修改比较复杂，能渐进式地逐步修改就很重要。

* */



/*
简单的做法

  如果想要移除一个参数，需要先确定函数体内没有使用该参数。

  修改函数声明，使其成为你期望的状态。

  找出所有使用旧的函数声明的地方，将它们改为使用新的函数声明。

  测试。

  最好能把大的修改拆成小的步骤，所以如果你既想修改函数名，又想添加参数，最好分成两步来做。
   （并且，不论何时，如果遇到了麻烦，请撤销修改，并改用迁移式做法。）

*
* */


/*
 迁移式做法
   如果有必要的话，先对函数体内部加以重构，使后面的提炼步骤易于开展。

   使用提炼函数（106）将函数体提炼成一个新函数。

      如果你打算沿用旧函数的名字，可以先给新函数起一个易于搜索的临时名字。

   如果提炼出的函数需要新增参数，用前面的简单做法添加即可。

   测试。

   对旧函数使用内联函数（115）。

   如果新函数使用了临时的名字，再次使用改变函数声明（124）将其改回原来的名字。

   测试。

   如果要重构的函数属于一个具有多态性的类，那么对于该函数的每个实现版本，你都需要通过“提炼出一个新函数”的方式添加一层间接，并把旧函数的调用转发给新函
数。如果该函数的多态性是在一个类继承体系中体现，那么只需要在超类上转发即可；如果各个实现类之间并没有一个共同的超类，那么就需要在每个实现类上做转发。

   如果要重构一个已对外发布的API，在提炼出新函数之后，你可以暂停重构，将原来的函数声明为“不推荐使用”（deprecated），然后给客户端一点时间转为使用新
函数。等你有信心所有客户端都已经从旧函数迁移到新函数，再移除旧函数的声明。

* */














































































