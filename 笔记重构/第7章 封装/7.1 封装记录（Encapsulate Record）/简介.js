

//曾用名：以数据类取代记录（Replace Record with Data Class）

//修改前
organization = {name: "Acme Gooseberries", country: "GB"};


//修改后
class Organization {
    constructor(data) {
       this._name = data.name;
       this._country = data.country;
    }
    get name(){
        return this._name;
    }
    set name(arg) {
        this._name = arg;
    }

    get country(){
        return this._country;
    }
    set country(arg) {
        this._country = arg;
    }
}


//以下是自己写的
let a = new Organization(organization);
a.name = 'sssss';
console.log(a.name);


/**
动机

   记录型结构是多数编程语言提供的一种常见特性。
     它们能直观地组织起存在关联的数据，让我可以将数据作为有意义的单元传递，而不仅是一堆数据的拼凑。
     但简单的记录型结构也有缺陷，最恼人的一点是，它强迫我清晰地区分“记录中存储的数据”和“通过计算得到的数据”。
   假使我要描述一个整数闭区间，我可以用{start: 1, end: 5}描述，或者用{start: 1, length: 5}（甚至还能用{end: 5, length: 5}，
     如果我想露两手华丽的编程技巧的话）。但不论如何存储，这3个值都是我想知道的，即区间的起点（start）和终点（end），以及区间的长度（length）。

   这就是对于可变数据，我总是更偏爱使用类对象而非记录的原因。对象可以隐藏结构的细节，仅为这3个值提供对应的方法。
     该对象的用户不必追究存储的细节和计算的过程。
     同时，这种封装还有助于字段的改名：我可以重新命名字段，但同时提供新老字段名的访问方法，这样我就可以渐进地修改调用方，直到替换全部完成。

   注意，我所说的偏爱对象，是对可变数据而言。
     如果数据不可变，我大可直接将这3个值保存在记录里，需要做数据变换时增加一个填充步骤即可。
     重命名记录也一样简单，你可以复制一个字段并逐步替换引用点。

   记录型结构可以有两种类型：
     一种需要声明合法的字段名字，另一种可以随便用任何字段名字。
     后者常由语言库本身实现，并通过类的形式提供出来，这些类称为散列（hash）、映射（map）、散列映射（hashmap）、字典（dictionary）或关联数组（associative array）等。
     很多编程语言都提供了方便的语法来创建这类记录，这使得它们在各种编程场景下都能大展身手。但使用这类结构也有缺陷，那就是一条记录上持有什么字段往往不够直观。
     比如说，如果我想知道记录里维护的字段究竟是起点/终点还是起点/长度，就只有查看它的创建点和使用点，除此以外别无他法。
     若这种记录只在程序的一个小范围里使用，那问题还不大，但若其使用范围变宽，“数据结构不直观”这个问题就会造成更多困扰。
     我可以重构它，使其变得更直观——但如果真需要这样做，那还不如使用类来得直接。

   程序中间常常需要互相传递嵌套的列表（list）或散列映射结构，这些数据结构后续经常需要被序列化成JSON或XML。
   这样的嵌套结构同样值得封装，这样，如果后续其结构需要变更或者需要修改记录内的值，封装能够帮我更好地应对变化。
 */


/**
做法

   对持有记录的变量使用封装变量（132），将其封装到一个函数中。
        记得为这个函数取一个容易搜索的名字。
   创建一个类，将记录包装起来，并将记录变量的值替换为该类的一个实例。然后在类上定义一个访问函数，用于返回原始的记录。修改封装变量的函数，令其使用这个访问函数。
   测试。
   新建一个函数，让它返回该类的对象，而非那条原始的记录。
   对于该记录的每处使用点，将原先返回记录的函数调用替换为那个返回实例对象的函数调用。使用对象上的访问函数来获取数据的字段，如果该字段的访问函数还不存在，那就创建一个。每次更改之后运行测试。
        如果该记录比较复杂，例如是个嵌套解构，那么先重点关注客户端对数据的更新操作，对于读取操作可以考虑返回一个数据副本或只读的数据代理。
   移除类对原始记录的访问函数，那个容易搜索的返回原始数据的函数也要一并删除。
   测试。
   如果记录中的字段本身也是复杂结构，考虑对其再次应用封装记录（162）或封装集合（170）手法。

 */





































