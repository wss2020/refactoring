/*
    曾用名：内联函数（Inline Method）

    反向重构：提炼函数（106）
*/


// 修改前
function getRating(driver) {
    return moreThanFiveLateDeliveries(driver) ? 2 : 1;
}

function moreThanFiveLateDeliveries(driver) {
    return driver.numberOfLateDeliveries > 5;
}


// 修改后
function getRating(driver) {
    return (driver.numberOfLateDeliveries > 5) ? 2 : 1;
}

/**
动机

    本书经常以简短的函数表现动作意图，这样会使代码更清晰易读。
    但有时候你会遇到某些函数，其内部代码和函数名称同样清晰易读。也可能你重构了该函数的内部实现，使其内容和其名称变得同样清晰。
    若果真如此，你就应该去掉这个函数，直接使用其中的代码。间接性可能带来帮助，但非必要的间接性总是让人不舒服。

    另一种需要使用内联函数的情况是：我手上有一群组织不甚合理的函数。可以将它们都内联到一个大型函数中，再以我喜欢的方式重新提炼出小函数。

    如果代码中有太多间接层，使得系统中的所有函数都似乎只是对另一个函数的简单委托，造成我在这些委托动作之间晕头转向，那么我通常都会使用内联函数。
    当然，间接层有其价值，但不是所有间接层都有价值。通过内联手法，我可以找出那些有用的间接层，同时将无用的间接层去除。

* */



/**
 做法

  检查函数，确定它不具多态性。
      如果该函数属于一个类，并且有子类继承了这个函数，那么就无法内联。

  找出这个函数的所有调用点。

  将这个函数的所有调用点都替换为函数本体。

  每次替换之后，执行测试。
      不必一次完成整个内联操作。如果某些调用点比较难以内联，可以等到时机成熟后再来处理。

  删除该函数的定义。

  被我这样一写，内联函数似乎很简单。但情况往往并非如此。对于递归调用、多返回点、内联至另一个对象中而该对象并无访问函数等复杂情况，我可以写上好几页。
我之所以不写这些特殊情况，原因很简单：如果你遇到了这样的复杂情况，就不应该使用这个重构手法。

*
* */












