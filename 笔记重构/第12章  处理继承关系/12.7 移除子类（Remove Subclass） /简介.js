/**
 曾用名：以字段取代子类（Replace Subclass with Fields）
 反向重构：以子类取代类型码（362）
 * */

//重构前
class Person {
    get genderCode() {return "X";}
}
class Male extends Person {
    get genderCode() {return "M";}
}
class Female extends Person {
    get genderCode() {return "F";}
}


//重构后
class Person1 {
    get genderCode() {return this._genderCode;}
}




/**
 动机

    子类很有用，它们为数据结构的多样和行为的多态提供支持，它们是针对差异编程的好工具。但随着软件的演化，子类所支持的变化可能会被搬移到别处，
 甚至完全去除，这时子类就失去了价值。有时添加子类是为了应对未来的功能，

    结果构想中的功能压根没被构造出来，或者用了另一种方式构造，使该子类不再被需要了。

    子类存在着就有成本，阅读者要花心思去理解它的用意，所以如果子类的用处太少，就不值得存在了。此时，最好的选择就是移除子类，将其替换为超类
 中的一个字段。
 */


/**
 做法

    使用以工厂函数取代构造函数（334），把子类的构造函数包装到超类的工厂函数中。
        如果构造函数的客户端用一个数组字段来决定实例化哪个子类，可以把这个判断逻辑放到超类的工厂函数中。

    如果有任何代码检查子类的类型，先用提炼函数（106）把类型检查逻辑包装起来，然后用搬移函数（198）将其搬到超类。每次修改后执行测试。

    新建一个字段，用于代表子类的类型。

    将原本针对子类的类型做判断的函数改为使用新建的类型字段。

    删除子类。

    测试。

    本重构手法常用于一次移除多个子类，此时需要先把这些子类都封装起来（添加工厂函数、搬移类型检查），然后再逐个将它们折叠到超类中。
 */















