// 反向重构：将引用对象改为值对象（252）

//修改前
let customer = new Customer(customerData);


//修改后
let customer = customerRepository.get(customerData.id);



/*
动机

   一个数据结构中可能包含多个记录，而这些记录都关联到同一个逻辑数据结构。
   例如，我可能会读取一系列订单数据，其中有多条订单属于同一个顾客。遇到这样的共享关系时，既可以把顾客信息作为值对象来看待，也可以将其视为引用对象。
       1）如果将其视为值对象，那么每份订单数据中都会复制顾客的数据；
       2）而如果将其视为引用对象，对于一个顾客，就只有一份数据结构，会有多个订单与之关联。

   如果顾客数据永远不修改，那么两种处理方式都合理。把同一份数据复制多次可能会造成一点困扰，但这种情况也很常见，不会造成太大问题。过多的数据复制有可能
会造成内存占用的问题，但就跟所有性能问题一样，这种情况并不常见。

   如果共享的数据需要更新，将其复制多份的做法就会遇到巨大的困难。此时我必须找到所有的副本，更新所有对象。只要漏掉一个副本没有更新，就会遭遇麻烦的数据
不一致。这种情况下，可以考虑将多份数据副本变成单一的引用，这样对顾客数据的修改就会立即反映在该顾客的所有订单中。

   把值对象改为引用对象会带来一个结果：对于一个客观实体，只有一个代表它的对象。这通常意味着我会需要某种形式的仓库，在仓库中可以找到所有这些实体对象。
只为每个实体创建一次对象，以后始终从仓库中获取该对象。

 */


/*
做法

   为相关对象创建一个仓库（如果还没有这样一个仓库的话）。

   确保构造函数有办法找到关联对象的正确实例。

   修改宿主对象的构造函数，令其从仓库中获取关联对象。每次修改后执行测试。
 */
















