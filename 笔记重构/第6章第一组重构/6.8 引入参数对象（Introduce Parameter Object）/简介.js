
// 修改前
function amountInvoiced(startDate, endDate) {}
function amountReceived(startDate, endDate) {}
function amountOverdue(startDate, endDate) {}

// 修改后
function amountInvoiced(aDateRange) {}
function amountReceived(aDateRange) {}
function amountOverdue(aDateRange) {}


/**
动机

    我常会看见，一组数据项总是结伴同行，出没于一个又一个函数。
    这样一组数据就是所谓的数据泥团，我喜欢代之以一个数据结构。

    将数据组织成结构是一件有价值的事，因为这让数据项之间的关系变得明晰。
    使用新的数据结构，参数的参数列表也能缩短。
    并且经过重构之后，所有使用该数据结构的函数都会通过同样的名字来访问其中的元素，从而提升代码的一致性。

    但这项重构真正的意义在于，它会催生代码中更深层次的改变。
    一旦识别出新的数据结构，我就可以重组程序的行为来使用这些结构。

    我会创建出函数来捕捉围绕这些数据的共用行为——可能只是一组共用的函数，
    也可能用一个类把数据结构与使用数据的函数组合起来。
    这个过程会改变代码的概念图景，将这些数据结构提升为新的抽象概念，可以帮助我更好地理解问题域。
    果真如此，这个重构过程会产生惊人强大的效用——但如果不用引入参数对象开启这个过程，后面的一切都不会发生。
 */




/**
做法
  如果暂时还没有一个合适的数据结构，就创建一个。
     我倾向于使用类，因为稍后把行为放进来会比较容易。我通常会尽量确保这些新建的数据结构是值对象[mf-vo]。
  测试。
  使用改变函数声明（124）给原来的函数新增一个参数，类型是新建的数据结构。
  测试。
  调整所有调用者，传入新数据结构的适当实例。每修改一处，执行测试。
  用新数据结构中的每项元素，逐一取代参数列表中与之对应的参数项，然后删除原来的参数。测试。
 */





























































































