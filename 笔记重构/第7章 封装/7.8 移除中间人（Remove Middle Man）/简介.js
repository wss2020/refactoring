//反向重构：隐藏委托关系（189）


//重构前
manager = aPerson.manager;
class Person {
    get manager() {
        return this.department.manager;
    }
}


//重构后
manager = aPerson.department.manager;


/**
 动机

    在隐藏委托关系（189）的“动机”一节中，我谈到了“封装受托对象”的好处。但是这层封装也是
 有代价的。每当客户端要使用受托类的新特性时，你就必须在服务端添加一个简单委托函数。随着受
 托类的特性（功能）越来越多，更多的转发函数就会使人烦躁。服务类完全变成了一个中间人（81），
 此时就应该让客户直接调用受托类。（这个味道通常在人们狂热地遵循迪米特法则时悄然出现。我总
 觉得，如果这条法则当初叫作“偶尔有用的迪米特建议”，如今能少很多烦恼。）

    很难说什么程度的隐藏才是合适的。还好，有了隐藏委托关系（189）和删除中间人，我大可不必
 操心这个问题，因为我可以在系统运行过程中不断进行调整。随着代码的变化，“合适的隐藏程度”这个
 尺度也相应改变。6个月前恰如其分的封装，现今可能就显得笨拙。重构的意义就在于：你永远不必说对
 不起——-只要把出问题的地方修补好就行了。
 */



/**
 做法
    为受托对象创建一个取值函数。
    对于每个委托函数，让其客户端转为连续的访问函数调用。每次替换后运行测试。
    替换完委托方法的所有调用点后，你就可以删掉这个委托方法了。
    这能通过可自动化的重构手法来完成，你可以先对受托字段使用封装变量（132），再应用内联函数（115）内联所有使用它的函数。
 */















