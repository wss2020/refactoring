
//重构前
const low = aRoom.daysTempRange.low;
const high = aRoom.daysTempRange.high;
if (aPlan.withinRange(low, high)) {}



//重构后
if (aPlan.withinRange(aRoom.daysTempRange)) {}


/**
 动机
    如果我看见代码从一个记录结构中导出几个值，然后又把这几个值一起传递给一个函数，我会更愿意把整个记录传给这个函数，
 在函数体内部导出所需的值。

    “传递整个记录”的方式能更好地应对变化：如果将来被调的函数需要从记录中导出更多的数据，我就不用为此修改参数列表。
 并且传递整个记录也能缩短参数列表，让函数调用更容易看懂。如果有很多函数都在使用记录中的同一组数据，处理这部分数据的
 逻辑常会重复，此时可以把这些处理逻辑搬移到完整对象中去。

    也有时我不想采用本重构手法，因为我不想让被调函数依赖完整对象，尤其是在两者不在同一个模块中的时候。

    从一个对象中抽取出几个值，单独对这几个值做某些逻辑操作，这是一种代码坏味道（依恋情结），通常标志着这段逻辑应该
 被搬移到对象中。保持对象完整经常发生在引入参数对象（140）之后，我会搜寻使用原来的数据泥团的代码，代之以使用新的对象。

    如果几处代码都在使用对象的一部分功能，可能意味着应该用提炼类（182）把这一部分功能单独提炼出来

    还有一种常被忽视的情况：调用者将自己的若干数据作为参数，传递给被调用函数。这种情况下，我可以将调用者的自我引用
 （在JavaScript中就是this）作为参数，直接传递给目标函数。
 */


/**
 做法
    新建一个空函数，给它以期望中的参数列表（即传入完整对象作为参数）。
        注意：给这个函数起一个容易搜索的名字，这样到重构结束时方便替换。
    在新函数体内调用旧函数，并把新的参数（即完整对象）映射到旧的参数列表（即来源于完整对象的各项数据）。
    执行静态检查。
    逐一修改旧函数的调用者，令其使用新函数，每次修改之后执行测试。
        注意：修改之后，调用处用于“从完整对象中导出参数值”的代码可能就没用了， 可以用移除死代码（237）去掉。
    所有调用处都修改过来之后，使用内联函数（115）把旧函数内联到新函数体内。
    给新函数改名，从重构开始时的容易搜索的临时名字，改为使用旧函数的名字，同时修改所有调用处。
 */















