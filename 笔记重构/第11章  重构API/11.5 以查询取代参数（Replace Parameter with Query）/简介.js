//曾用名：以函数取代参数（Replace Parameter with Method）

//反向重构：以参数取代查询（327）

//重构前
availableVacation(anEmployee, anEmployee.grade);

function availableVacation(anEmployee, grade) {
// calculate vacation...
}


//重构后
availableVacation(anEmployee)

function availableVacation(anEmployee) {
    const grade = anEmployee.grade;
// calculate vacation...
}


/**
 动机
    函数的参数列表应该总结该函数的可变性，标示出函数可能体现出行为差异的主要方式。和任何代码中的
 语句一样，参数列表应该尽量避免重复，并且参数列表越短就越容易理解。

    如果调用函数时传入了一个值，而这个值由函数自己来获得也是同样容易， 这就是重复。这个本不必要
 的参数会增加调用者的难度，因为它不得不找出正确的参数值，其实原本调用者是不需要费这个力气的。

    “同样容易”四个字，划出了一条判断的界限。去除参数也就意味着“获得正确的参数值”的责任被转移：
 有参数传入时，调用者需要负责获得正确的参数值；参数去除后，责任就被转移给了函数本身。一般而言，
 我习惯于简化调用方，因此我愿意把责任移交给函数本身，但如果函数难以承担这份责任，就另当别论了。

    不使用以查询取代参数最常见的原因是，移除参数可能会给函数体增加不必要的依赖关系——迫使函数
 访问某个程序元素，而我原本不想让函数了解这个元素的存在。这种“不必要的依赖关系”除了新增的以外，
 也可能是我想要稍后去除的，例如为了去除一个参数，我可能会在函数体内调用一个有问题的函数，或是从
 一个对象中获取某些原本想要剥离出去的数据。在这些情况下，都应该慎重考虑使用以查询取代参数。

    如果想要去除的参数值只需要向另一个参数查询就能得到，这是使用以查询取代参数最安全的场景。如果
 可以从一个参数推导出另一个参数，那么几乎没有任何理由要同时传递这两个参数。

    另外有一件事需要留意：如果在处理的函数具有引用透明性（referential transparency，即，
 不论任何时候，只要传入相同的参数值，该函数的行为永远一致），这样的函数既容易理解又容易测试，我不想
 使其失去这种优秀品质。我不会去掉它的参数，让它去访问一个可变的全局变量。
 */



/**
 做法
    如果有必要，使用提炼函数（106）将参数的计算过程提炼到一个独立的函数中。
    将函数体内引用该参数的地方改为调用新建的函数。每次修改后执行测试。
    全部替换完成后，使用改变函数声明（124）将该参数去掉。
 */



























