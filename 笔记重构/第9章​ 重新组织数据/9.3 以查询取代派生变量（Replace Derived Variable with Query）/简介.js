//修改前
class test {
    get discountedTotal() {
        return this._discountedTotal;
    }
    set discount(aNumber) {
        const old = this._discount;
        this._discount = aNumber;
        this._discountedTotal += old - aNumber;
    }
}


//修改后
class test {
    get discountedTotal() {
        return this._baseTotal - this._discount;
    }
    set discount(aNumber) {
        this._discount = aNumber;
    }
}



/**
动机

   可变数据是软件中最大的错误源头之一。对数据的修改常常导致代码的各个部分以丑陋的形式互相耦合：在一处修改数据，却在另一处造成难以发现的破坏。很多时候，
完全去掉可变数据并不现实，但我还是强烈建议：尽量把可变数据的作用域限制在最小范围。

   有些变量其实可以很容易地随时计算出来。如果能去掉这些变量，也算朝着消除可变性的方向迈出了一大步。计算常能更清晰地表达数据的含义，而且也避免了“源数据
修改时忘了更新派生变量”的错误。

   有一种合理的例外情况：如果计算的源数据是不可变的，并且我们可以强制要求计算的结果也是不可变的，那么就不必重构消除计算得到的派生变量。因此，
“根据源数据生成新数据结构”的变换操作可以保持不变，即便我们可以将其替换为计算操作。实际上，这是两种不同的编程风格：
         一种是对象风格，把一系列计算得出的属性包装在数据结构中；
         另一种是函数风格，将一个数据结构变换为另一个数据结构。
   如果源数据会被修改，而你必须负责管理派生数据结构的整个生命周期，那么对象风格显然更好。但如果源数据不可变，或者派生数据用过即弃，那么两种风格都可行。

 */



/**
做法

   识别出所有对变量做更新的地方。如有必要，用拆分变量（240）分割各个更新点。

   新建一个函数，用于计算该变量的值。

   用引入断言（302）断言该变量和计算函数始终给出同样的值。
         如有必要，用封装变量（132）将这个断言封装起来。

   测试。

   修改读取该变量的代码，令其调用新建的函数。

   测试。

   用移除死代码（237）去掉变量的声明和赋值。
*/























