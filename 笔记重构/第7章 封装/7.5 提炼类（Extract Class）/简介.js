// 反向重构：内联类（186）

//重构前
class Person {
    get officeAreaCode() {
        return this._officeAreaCode;
    }
    get officeNumber() {
        return this._officeNumber;
    }
}

//重构后
class Person1 {
    get officeAreaCode() {
        return this._telephoneNumber.areaCode;
    }
    get officeNumber() {
        return this._telephoneNumber.number;
    }
}
class TelephoneNumber {
    get areaCode() {
        return this._areaCode;
    }
    get number() {
        return this._number;
    }
}


/**
动机
    你也许听过类似这样的建议：一个类应该是一个清晰的抽象，只处理一些明确的责任，等等。但是在实际工作中，类会不断成长扩展。
 你会在这儿加入一些功能，在那儿加入一些数据。给某个类添加一项新责任时，你会觉得不值得为这项责任分离出一个独立的类。于是，
 随着责任不断增加，这个类会变得过分复杂。很快，你的类就会变成一团乱麻。

    设想你有一个维护大量函数和数据的类。这样的类往往因为太大而不易理解。此时你需要考虑哪些部分可以分离出去，并将它们分离
 到一个独立的类中。如果某些数据和某些函数总是一起出现，某些数据经常同时变化甚至彼此相依， 这就表示你应该将它们分离出去。
 一个有用的测试就是问你自己，如果你搬移了某些字段和函数，会发生什么事？其他字段和函数是否因此变得无意义？

    另一个往往在开发后期出现的信号是类的子类化方式。如果你发现子类化只影响类的部分特性，或如果你发现某些特性需要以一种方式
 来子类化，某些特性则需要以另一种方式子类化，这就意味着你需要分解原来的类。
 */


/**
做法
    决定如何分解类所负的责任。
    创建一个新的类，用以表现从旧类中分离出来的责任。
    注意：如果旧类剩下的责任与旧类的名称不符，为旧类改名。
    构造旧类时创建一个新类的实例，建立“从旧类访问新类”的连接关系。
    对于你想搬移的每一个字段，运用搬移字段（207）搬移之。每次更改后运行测试。
    使用搬移函数（198）将必要函数搬移到新类。先搬移较低层函数（也就是“被其他函数调用”多于“调用其他函数”者）。每次更改后运行测试。
    检查两个类的接口，去掉不再需要的函数，必要时为函数重新取一个适合新环境的名字。
    决定是否公开新的类。如果确实需要，考虑对新类应用将引用对象改为值对象（252）使其成为一个值对象。
*/


