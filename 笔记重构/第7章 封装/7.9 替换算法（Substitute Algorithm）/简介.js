// 重构前
function foundPerson(people) {
    for (let i = 0; i < people.length; i++) {
        if (people[i] === "Don") {
            return "Don";
        }
        if (people[i] === "John") {
            return "John";
        }
        if (people[i] === "Kent") {
            return "Kent";
        }
    }
    return "";
}

// 重构后
function foundPerson(people) {
    const candidates = ["Don", "John", "Kent"];
    return people.find(p => candidates.includes(p)) || '';
}

/**
 动机
    我从没试过给猫剥皮，听说有好几种方法，我敢肯定，其中某些方法会比另一些简单。算法也是如此。如果我
 发现做一件事可以有更清晰的方式，我就会用比较清晰的方式取代复杂的方式。“重构”可以把一些复杂的东西分解
 为较简单的小块，但有时你就必须壮士断腕，删掉整个算法，代之以较简单的算法。随着对问题有了更多理解，我
 往往会发现，在原先的做法之外，有更简单的解决方案， 此时我就需要改变原先的算法。如果我开始使用程序库，
 而其中提供的某些功能/特性与我自己的代码重复，那么我也需要改变原先的算法。

     有时我会想修改原先的算法，让它去做一件与原先略有差异的事。这时候可以先把原先的算法替换为一个较易
 修改的算法，这样后续的修改会轻松许多。

    使用这项重构手法之前，我得确定自己已经尽可能分解了原先的函数。替换一个巨大且复杂的算法是非常困难的
 ，只有先将它分解为较简单的小型函数，我才能很有把握地进行算法替换工作。
 */


/**
做法

    整理一下待替换的算法，保证它已经被抽取到一个独立的函数中。
    先只为这个函数准备测试，以便固定它的行为。
    准备好另一个（替换用）算法。执行静态检查。
    运行测试，比对新旧算法的运行结果。如果测试通过，那就大功告成；否则， 在后续测试和调试过程中，以旧算法为比较参照标准。

*/
















