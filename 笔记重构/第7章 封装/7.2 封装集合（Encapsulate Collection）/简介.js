//修改前
class Person {
    get courses() {
        return this._courses;
    }
    set courses(aList) {
        this._courses = aList;
    }
}

//修改后
class Person {
    get courses() {
        return this._courses.slice();
    }
    addCourse(aCourse) {}
    removeCourse(aCourse) {}
}



/**
动机

   我喜欢封装程序中的所有可变数据。这使我很容易看清楚数据被修改的地点和修改方式，这样当我需要更改数据结构时就非常方便。我们通常鼓励封装——使用面向对象
技术的开发者对封装尤为重视——但封装集合时人们常常犯一个错误：只对集合变量的访问进行了封装，但依然让取值函数返回集合本身。这使得集合的成员变量可以直接被
修改，而封装它的类则全然不知，无法介入。

   为避免此种情况，我会在类上提供一些修改集合的方法——通常是“添加”和“移除”方法。这样就可使对集合的修改必须经过类，当程序演化变大时，我依然能轻易找出
修改点。

   只要团队拥有良好的习惯，就不会在模块以外修改集合，仅仅提供这些修改方法似乎也就足够。然而，依赖于别人的好习惯是不明智的，一个细小的疏忽就可能带来难
以调试的bug。更好的做法是，不要让集合的取值函数返回原始集合，这就避免了客户端的意外修改。

   一种避免直接修改集合的方法是，永远不直接返回集合的值。这种方法提倡，不要直接使用集合的字段，而是通过定义类上的方法来代替，比如将
aCustomer.orders.size替换为aCustomer.numberOfOrders。我不同意这种做法。现代编程语言都提供了丰富的集合类和标准接口，能够组合成很多有价值的用
法，比如集合管道（Collection Pipeline）[mf-cp]等。使用特殊的类方法来处理这些场景，会增加许多额外代码，使集合操作容易组合的特性大打折扣。

   还有一种方法是，以某种形式限制集合的访问权，只允许对集合进行读操作。比如，在Java中可以很容易地返回集合的一个只读代理，这种代理允许用户读取集合，
但会阻止所有更改操作——Java的代理会抛出一个异常。有一些库在构造集合时也用了类似的方法，将构造出的集合建立在迭代器或枚举对象的基础上，因为迭代器也不能
修改它迭代的集合。

   也许最常见的做法是，为集合提供一个取值函数，但令其返回一个集合的副本。这样即使有人修改了副本，被封装的集合也不会受到影响。这可能带来一些困惑，特别
是对那些已经习惯于通过修改返回值来修改原集合的开发者——但更多的情况下，开发者已经习惯于取值函数返回副本的做法。如果集合很大，这个做法可能带来性能问题，
好在多数列表都没有那么大，此时前述的性能优化基本守则依然适用（见2.8节）。

   使用数据代理和数据复制的另一个区别是，对源数据的修改会反映到代理上，但不会反映到副本上。大多数时候这个区别影响不大，因为通过此种方式访问的列表通常
生命周期都不长。

   采用哪种方法并无定式，最重要的是在同个代码库中做法要保持一致。我建议只用一种方案，这样每个人都能很快习惯它，并在每次调用集合的访问函数时期望相同的
行为。

*/


/**
做法

    如果集合的引用尚未被封装起来，先用封装变量（132）封装它。  在类上添加用于“添加集合元素”和“移除集合元素”的函数。

    如果存在对该集合的设值函数，尽可能先用移除设值函数（331）移除它。如果不能移除该设值函数，至少让它返回集合的一份副本。

    执行静态检查。

    查找集合的引用点。如果有调用者直接修改集合，令该处调用使用新的添加/移除元素的函数。每次修改后执行测试。

    修改集合的取值函数，使其返回一份只读的数据，可以使用只读代理或数据副本。

    测试。
 */












