/*
 */


//修改前
function base(aReading) {}
function taxableCharge(aReading) {}


//修改后
function enrichReading(argReading) {
    const aReading = _.cloneDeep(argReading);
    aReading.baseCharge = base(aReading);
    aReading.taxableCharge = taxableCharge(aReading);
    return aReading;
}


/*
动机
   在软件中，经常需要把数据“喂”给一个程序，让它再计算出各种派生信息。
   这些派生数值可能会在几个不同地方用到，因此这些计算逻辑也常会在用到派生数据的地方重复。
   我更愿意把所有计算派生数据的逻辑收拢到一处，这样始终可以在固定的地方找到和更新这些逻辑，避免到处重复。

   一个方式是采用数据变换（transform）函数：这种函数接受源数据作为输入，计算出所有的派生数据，将派生数据以字段形式填入输出数据。
   有了变换函数，我就始终只需要到变换函数中去检查计算派生数据的逻辑。

   函数组合成变换的替代方案是函数组合成类（144），后者的做法是先用源数据创建一个类，再把相关的计算逻辑搬移到类中。这两个重构手法都很有用，

   我常会根据代码库中已有的编程风格来选择使用其中哪一个。
   不过，两者有一个重要的区别：
      如果代码中会对源数据做更新，那么使用类要好得多；
      如果使用变换，派生数据会被存储在新生成的记录中，一旦源数据被修改，我就会遭遇数据不一致。

   我喜欢把函数组合起来的原因之一，是为了避免计算派生数据的逻辑到处重复。
   从道理上来说，只用提炼函数（106）也能避免重复，但孤立存在的函数常常很难找到，
   只有把函数和它们操作的数据放在一起，用起来才方便。引入变换（或者类）都是为了让相关的逻辑找起来方便。
 */


/*
做法

  创建一个变换函数，输入参数是需要变换的记录，并直接返回该记录的值。
     这一步通常需要对输入的记录做深复制（deep copy）。此时应该写个测试，确保变换不会修改原来的记录。

  挑选一块逻辑，将其主体移入变换函数中，把结果作为字段添加到输出记录中。修改客户端代码，令其使用这个新字段。
     如果计算逻辑比较复杂，先用提炼函数（106）提炼之。

  测试。

  针对其他相关的计算逻辑，重复上述步骤。
 */



















