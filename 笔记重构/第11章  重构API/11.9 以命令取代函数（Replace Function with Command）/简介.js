//曾用名：以函数对象取代函数（Replace Method with Method Object）
//反向重构：以函数取代命令（344）

//重构前
function score(candidate, medicalExam, scoringGuide) {
    let result = 0;
    let healthLevel = 0;
    // long body code
}

//重构后
class Scorer {
    constructor(candidate, medicalExam, scoringGuide) {
        this._candidate = candidate;
        this._medicalExam = medicalExam;
        this._scoringGuide = scoringGuide;
    }

    execute() {
        this._result = 0;
        this._healthLevel = 0;
        // long body code
    }
}


/**
动机
    函数，不管是独立函数，还是以方法（method）形式附着在对象上的函数，是程序设计的基本构造块。不过，
 将函数封装成自己的对象，有时也是一种有用的办法。这样的对象我称之为“命令对象”（command object），、
 或者简称“命令”（command）。这种对象大多只服务于单一函数，获得对该函数的请求，执行该函数，就是这种对象
 存在的意义。

    与普通的函数相比，命令对象提供了更大的控制灵活性和更强的表达能力。除了函数调用本身，命令对象还可以
 支持附加的操作，例如撤销操作。我可以通过命令对象提供的方法来设值命令的参数值，从而支持更丰富的生命周期
 管理能力。我可以借助继承和钩子对函数行为加以定制。如果我所使用的编程语言支持对象但不支持函数作为一等公
 民，通过命令对象就可以给函数提供大部分相当于一等公民的能力。同样，即便编程语言本身并不支持嵌套函数，我
 也可以借助命令对象的方法和字段把复杂的函数拆解开，而且在测试和调试过程中可以直接调用这些方法。

    所有这些都是使用命令对象的好理由，所以我要做好准备，一旦有需要，就能把函数重构成命令。不过我们不能忘记，
 命令对象的灵活性也是以复杂性作为代价的。所以，如果要在作为一等公民的函数和命令对象之间做个选择，95%的时候
 我都会选函数。只有当我特别需要命令对象提供的某种能力而普通的函数无法提供这种能力时，我才会考虑使用命令对象。
 */



/**
做法
    为想要包装的函数创建一个空的类，根据该函数的名字为其命名。
    使用搬移函数（198）把函数移到空的类里。
    注意：保持原来的函数作为转发函数，至少保留到重构结束之前才删除。
    遵循编程语言的命名规范来给命令对象起名。如果没有合适的命名规范，就给命令对象中负责实
 际执行命令的函数起一个通用的名字，例如“execute”或者“call”。
    可以考虑给每个参数创建一个字段，并在构造函数中添加对应的参数。
*/
