// 反向重构：以命令取代函数（337）

//重构前
class ChargeCalculator {
    constructor(customer, usage) {
        this._customer = customer;
        this._usage = usage;
    }

    execute() {
        return this._customer.rate * this._usage;
    }
}

//重构后
function charge(customer, usage) {
    return customer.rate * usage;
}


/**
动机
    命令对象为处理复杂计算提供了强大的机制。借助命令对象，可以轻松地将原本复杂的函数拆解为多个方法，彼此之间通过字段共享
 状态；拆解后的方法可以分别调用；开始调用之前的数据状态也可以逐步构建。但这种强大是有代价的。大多数时候，我只是想调用一
 个函数，让它完成自己的工作就好。如果这个函数不是太复杂，那么命令对象可能显得费而不惠，我就应该考虑将其变回普通的函数。

 */


/**
做法
    运用提炼函数（106），把“创建并执行命令对象”的代码单独提炼到一个函数中。
 注意：这一步会新建一个函数，最终这个函数会取代现在的命令对象。
    对命令对象在执行阶段用到的函数，逐一使用内联函数（115）。
 注意：如果被调用的函数有返回值，请先对调用处使用提炼变量（119），然后再使用内联函数（115）。
    使用改变函数声明（124），把构造函数的参数转移到执行函数。
    对于所有的字段，在执行函数中找到引用它们的地方，并改为使用参数。每次修改后都要测试。
    把“调用构造函数”和“调用执行函数”两步都内联到调用方（也就是最终要替换命令对象的那个函数）。
    测试。
    用移除死代码（237）把命令类消去。
*/




