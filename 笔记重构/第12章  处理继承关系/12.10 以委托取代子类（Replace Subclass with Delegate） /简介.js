// 重构前
class Order {
    get daysToShip() {
        return this._warehouse.daysToShip;
    }
}

class PriorityOrder extends Order {
    get daysToShip() {
        return this._priorityPlan.daysToShip;
    }
}



// 重构后
class Order {
    get daysToShip() {
        return (this._priorityDelegate)
            ? this._priorityDelegate.daysToShip : this._warehouse.daysToShip;
    }
}

class PriorityOrderDelegate {
    get daysToShip() {
        return this._priorityPlan.daysToShip
    }
}


/**
 动机
    如果一个对象的行为有明显的类别之分，继承是很自然的表达方式。我可以把共用的数据和行为放在超类中，每个子类根据需要覆写部分特性。
 在面向对象语言中，继承很容易实现，因此也是程序员熟悉的机制。

    但继承也有其短板。最明显的是，继承这张牌只能打一次。导致行为不同的原因可能有多种，但继承只能用于处理一个方向上的变化。比如说，
 我可能希望“人”的行为根据“年龄段”不同，并且根据“收入水平”不同。使用继承的话，子类可以是“年轻人”和“老人”，也可以是“富人”和“穷人”，
 但不能同时采用两种继承方式。

    更大的问题在于，继承给类之间引入了非常紧密的关系。在超类上做任何修改，都很可能破坏子类，所以我必须非常小心，并且充分理解子类
 如何从超类派生。如果两个类的逻辑分处不同的模块、由不同的团队负责，问题就会更麻烦。

    这两个问题用委托都能解决。对于不同的变化原因，我可以委托给不同的类。委托是对象之间常规的关系。与继承关系相比，使用委托关系时
 接口更清晰、耦合更少。因此，继承关系遇到问题时运用以委托取代子类是常见的情况。

    有一条流行的原则：“对象组合优于类继承”（“组合”跟“委托”是同一回事）。很多人把这句话解读为“继承有害”，并因此声称绝不应该使用继承。我经
 常使用继承，部分是因为我知道，如果稍后需要改变，我总可以使用以委托取代子类。继承是一种很有价值的机制，大部分时候能达到效果，不会带来问题。
 所以我会从继承开始，如果开始出现问题，再转而使用委托。这种用法与前面说的原则实际上是一致的——这条出自名著《设计模式》[gof]的原则解释了
 如何让继承和组合协同工作。这条原则之所以强调“组合优于继承”，其实是对彼时继承常被滥用的回应。

    熟悉《设计模式》一书的读者可以这样来理解本重构手法，就是用状态（State）模式或者策略（Strategy）模式取代子类。这两个模式在结构上
 是相同的，都是由宿主对象把责任委托给另一个继承体系。以委托取代子类并非总会需要建立一个继承体系来接受委托（下面第一个例子就没有），不过
 建立一个状态或策略的继承体系经常都是有用的。
 */


/**
 做法
    如果构造函数有多个调用者，首先用以工厂函数取代构造函数（334）把构造函数包装起来。

    创建一个空的委托类，这个类的构造函数应该接受所有子类特有的数据项，并且经常以参数的形式接受一个指回超类的引用。

    在超类中添加一个字段，用于安放委托对象。

    修改子类的创建逻辑，使其初始化上述委托字段，放入一个委托对象的实例。( 这一步可以在工厂函数中完成，也可以在构造函数
 中完成（如果构造函数有足够的信息以创建正确的委托对象的话）。

    选择一个子类中的函数，将其移入委托类。

    使用搬移函数（198）手法搬移上述函数，不要删除源类中的委托代码。(如果这个方法用到的其他元素也应该被移入委托对象
 ，就把它们一并搬移。如果它用到的元素应该留在超类中，就在委托对象中添加一个字段，令其指向超类的实例。)

    如果被搬移的源函数还在子类之外被调用了，就把留在源类中的委托代码从子类移到超类，并在委托代码之前加上卫语句，
 检查委托对象存在。如果子类之外已经没有其他调用者，就用移除死代码（237）去掉已经没人使用的委托代码。（如果有多个委托类，
 并且其中的代码出现了重复，就使用提炼超类（375）手法消除重复。此时如果默认行为已经被移入了委托类的超类，源超类的委托函数就
 不再需要卫语句了。

    测试。

    重复上述过程，直到子类中所有函数都搬到委托类。

    找到所有调用子类构造函数的地方，逐一将其改为使用超类的构造函数。

    测试。

    运用移除死代码（237）去掉子类。
 */












